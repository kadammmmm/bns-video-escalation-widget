import { DataFetcherValueType } from "./DataFetcher";
import { QmServiceTypes } from "./QmPerformanceDataRequester";
export declare namespace AgentPerformanceTypes {
    namespace DataFetcherTypes {
        type DataFetcherCoreData = {
            [key in QmServiceTypes.CoreMetricColumn | QmServiceTypes.MetadataColumn]?: DataFetcherValueType;
        };
        const DATA_FETCHER_TEAM_PREFIX = "teamAvg";
        type DataFetcherTeamAvgData = {
            [key in TeamAvgColumn]?: DataFetcherValueType;
        };
        type DataFetcherChannelValue = {
            [K in QmServiceTypes.ChannelType]?: DataFetcherValueType;
        };
        type DetailedPerformanceDataObj = {
            inbound?: DataFetcherChannelValue;
            outbound?: DataFetcherChannelValue;
        };
        type DetailedCoreMetricData = {
            [key in QmServiceTypes.CoreMetricColumn]?: DetailedPerformanceDataObj;
        };
        type DetailedPerformanceData = {
            agentId: string;
            teamId: string;
            agentData: DetailedCoreMetricData;
            teamAvgData: DetailedCoreMetricData;
        };
        type AgentsDetailedPerformanceData = DetailedPerformanceData[];
        type AgentPerformanceData = DataFetcherCoreData & DataFetcherTeamAvgData;
        enum TeamAvgColumn {
            TeamAvgConnectedCount = "teamAvgConnectedCount",
            TeamAvgConnectedDurationMs = "teamAvgConnectedDurationMs",
            TeamAvgAverageConnectedDurationMs = "teamAvgAverageConnectedDurationMs",
            TeamAvgAverageHandleTimeMs = "teamAvgAverageHandleTimeMs",
            TeamAvgConsultRequestCount = "teamAvgConsultRequestCount",
            TeamAvgConsultRequestDurationMs = "teamAvgConsultRequestDurationMs",
            TeamAvgConsultRequestRate = "teamAvgConsultRequestRate",
            TeamAvgConsultAnswerCount = "teamAvgConsultAnswerCount",
            TeamAvgConsultAnswerDurationMs = "teamAvgConsultAnswerDurationMs",
            TeamAvgAverageConsultDurationMs = "teamAvgAverageConsultDurationMs",
            TeamAvgHoldCount = "teamAvgHoldCount",
            TeamAvgHoldDurationMs = "teamAvgHoldDurationMs",
            TeamAvgHoldRate = "teamAvgHoldRate",
            TeamAvgHoldDurationRatioMs = "teamAvgHoldDurationRatioMs",
            TeamAvgAverageHoldDurationMs = "teamAvgAverageHoldDurationMs",
            TeamAvgTransferCount = "teamAvgTransferCount",
            TeamAvgTransferRate = "teamAvgTransferRate",
            TeamAvgAverageWrapupDurationMs = "teamAvgAverageWrapupDurationMs",
            TeamAvgOccupancy = "teamAvgOccupancy",
            TeamAvgAverageEvaluationScore = "teamAvgAverageEvaluationScore",
            TeamAvgAutoCSAT = "teamAvgAutoCSAT",
            TeamAvgSentimentScore = "teamAvgSentimentScore",
            TeamAvgTimeBetweenChatReplies = "teamAvgTimeBetweenChatReplies",
            TeamAvgCrossTalk = "teamAvgCrossTalk",
            TeamAvgTalkRatio = "teamAvgTalkRatio",
            TeamAvgSilenceMonitor = "teamAvgSilenceMonitor",
            TeamAvgTotalLoggedInDuration = "teamAvgTotalLoggedInDurationMs"
        }
        const TEAM_AVG_TO_CORE_METRIC_MAP: Record<TeamAvgColumn, QmServiceTypes.CoreMetricColumn>;
        type AllColumnTypes = QmServiceTypes.MetadataColumn | QmServiceTypes.CoreMetricColumn | TeamAvgColumn;
        type ColumnValue = {
            [key: string]: ColumnValueType;
        };
        type ColumnValueType = DataFetcherValueType;
        type Row = {
            [columnName: string]: AgentPerformanceTypes.DataFetcherTypes.ColumnValueType;
        };
        type Table = Row[];
    }
    type Question = {
        id: string;
        text: string;
        tooltipText: string | null;
        questionType: QuestionType;
        options: Option[];
        weight: number;
        autoFailThreshold?: number;
        selectedAnswer?: string;
        comment?: string;
        aiSuggestedAnswer?: string;
        aiSuggestedAnswerJustification?: string;
        aiEvalDetails?: AIEvalDetails[];
        numericOnly?: boolean;
    };
    interface TeamAssignmentsResponse {
        formId: string;
        team: {
            teamId: string;
        };
        creationTime: string;
    }
    interface QueueAssignmentsResponse {
        formId: string;
        queue: {
            queueId: string;
        };
        creationTime: string;
    }
    interface AgentAssignmentsResponse {
        formId: string;
        agent: {
            userId: string;
            displayName: string;
        };
        creationTime: string;
    }
    type Section = {
        id: string;
        name: string;
        questions: Question[];
        manualEvaluationRequired?: boolean;
    };
    type Interaction = {
        interactionId: string;
        startTime: number;
        agent: {
            userId: string;
            ccUserId: string;
            displayName: string;
        };
    };
    interface FormStats {
        formId: string;
        averageScore: number;
        numberOfEvaluations: number;
    }
    interface TeamKpi {
        teamId?: string;
        name: string;
        lowerBound: number;
        upperBound: number;
        weight: number;
        higherIsBetter: boolean;
        context?: string;
    }
    type CoachingInsightsConfig = {
        id: string;
        teamName: string;
        evaluationScoreLowerLimit: number;
        evaluationScoreUpperLimit: number;
        connectedDurationLowerLimit: number;
        connectedDurationUpperLimit: number;
        holdDurationLowerLimit: number;
        holdDurationUpperLimit: number;
        wrapUpDurationLowerLimit: number;
        wrapUpDurationUpperLimit: number;
    };
    type Option = {
        id?: number;
        text: string;
        weight: number;
        autoFail: boolean;
    };
    type Answer = {
        id?: string;
        questionId: string;
        comment?: string;
        selectedOptions: {
            id: number;
            text: string;
            weight: number;
        }[];
    };
    type EvaluationDefinition = {
        id?: string;
        interaction: Interaction;
        status: EvaluationStatus;
        formId: string;
        createdAt?: string;
        lastModifiedAt?: string;
        answers: Answer[];
        lastModifiedBy?: {
            userId: string;
            ccUserId: string;
            displayName: string;
        };
        score?: number;
        isAutoEval?: boolean;
    };
    type AgentEvaluationDetails = {
        ccUserId: string;
        displayName: string;
    };
    type FormEvaluationFrequencies = {
        teamFrequency?: number;
        queueFrequency?: number;
        agentFrequency?: number;
    };
    type FormDefinition = {
        id: string;
        name: string;
        sections: Section[];
        status: EvaluationFormStatus;
        description?: string;
        maxPossibleScore?: number;
    };
    type FormResponse = FormDefinition & {
        aiEvaluationFrequency: FormEvaluationFrequencies;
    };
    type AIAssistedEvaluationResponse = {
        id: string;
        score: number;
        status: EvaluationStatus;
        interaction: Interaction;
        formId: string;
        suggestedAnswers: SuggestedAnswers[];
    };
    type SuggestedAnswers = {
        questionId: string;
        justification?: string;
        selectedOptions: AIEvalDetails[];
    };
    type AIEvalDetails = {
        id: number;
        text: string;
        weight: number;
        confidence?: number;
        detectionPoints?: AIDetectionPoint[];
    };
    type AIDetectionPoint = {
        startTimeMs: number;
        endTimeMs: number;
        text: string;
    };
    type FetchOrgFormsResponse = {
        data: FormDefinition[];
        meta?: {
            pageNumber: number;
            pageSize: number;
            totalRecords: number;
            totalPages: number;
        };
    };
    type AgentPerformanceInfo = {
        agentId: string;
        numberOfEvaluationInteractions: number;
        numberOfTranscriptAnalysisInteractions: number;
        averageEvaluationScore?: number;
    };
    type FetchAgentPerformanceScoresResponse = {
        agentPerformanceInfos: AgentPerformanceInfo[];
    };
    type CoachingAnalysisTriggerRequest = {
        agent: {
            userId: string;
            displayName: string;
        };
        teamId: string;
        startTime: number;
        endTime: number;
    };
    type CoachingAnalysisTriggerResponse = {
        status: string;
        analysisId: string;
    };
    type TriggerModelTrainingResponse = {
        status: "IN_PROGRESS" | "ACCEPTED" | "DONE";
    };
    type CoachingAnalysisResultResponse = {
        result: string;
        startTime: number;
        endTime: number;
        agent: {
            userId: string;
            displayName: string;
        };
        coachingPromptVersion: number;
        teamId: string;
    };
    type InteractionRule = {
        metricType: InteractionRuleMetricType;
        operator: InteractionRuleOperatorType;
        value: string;
    };
    type FetchInteractionRulesResponse = {
        formId: string;
        rules: InteractionRule[];
    };
    interface CoachingAgentRef {
        userId: string;
        displayName: string;
    }
    interface TriggerCoachingAnalysisParams {
        orgId: string;
        agent: CoachingAgentRef;
        teamId: string;
        startTime: number;
        endTime: number;
    }
    interface TriggerModelTrainingParams {
        orgId: string;
        formId: string;
    }
    enum EvaluationFormStatus {
        ARCHIVED = "ARCHIVED",
        DRAFT = "DRAFT",
        ACTIVE = "ACTIVE"
    }
    interface FetchCoachingAnalysisParams {
        orgId: string;
        analysisId: string;
    }
    enum EvaluationMode {
        VIEW = "VIEW",
        EDIT = "EDIT",
        CREATE = "CREATE"
    }
    enum EvaluationStatus {
        ARCHIVED = "ARCHIVED",
        DRAFT = "DRAFT",
        ACTIVE = "ACTIVE",
        PUBLISHED = "PUBLISHED",
        INCOMPLETE = "INCOMPLETE",
        AUTO_EVALUATED = "AUTO_EVALUATED"
    }
    enum EvaluationMetricEvents {
        VIEWING_PUBLISHED_EVALUATION = "viewing-published-evaluation",
        RETRIEVE_EVALUATION_FORMS = "retrieve-evaluation-forms",
        RETRIEVE_EVALUATION_FORM = "retrieve-evaluation-form",
        RETRIEVE_EVALUATION = "retrieve-evaluation",
        SAVE_EVALUATION = "save-evaluation",
        PUBLISH_EVALUATION = "publish-evaluation",
        DISCARD_EVALUATION = "discard-evaluation",
        CREATE_EVALUATION = "create-evaluation",
        AI_ASSIST_SUGGESTIONS_UNAVAILABLE = "ai-assist-suggestions-unavailable",
        ERROR_RETRIEVING_AI_ASSIST_SUGGESTIONS = "error-retrieving-ai-assist-suggestions",
        AI_ASSIST_POLLING_MAX_RETRIES = "ai-assist-polling-max-retries",
        AI_ASSIST_POLLING_SUCCESS = "ai-assist-polling-success",
        AI_ASSIST_POLLING_FAILED = "ai-assist-polling-failed"
    }
    enum QuestionType {
        YES_NO = "YES_NO",
        SCALE = "SCALE",
        SINGLE_SELECT = "SINGLE_SELECT"
    }
    enum InteractionRuleOperatorType {
        EQUALS = "EQUALS",
        NOT_EQUALS = "NOT_EQUALS",
        GREATER_THAN = "GREATER_THAN",
        GREATER_THAN_OR_EQUAL = "GREATER_THAN_OR_EQUAL",
        LESS_THAN = "LESS_THAN",
        LESS_THAN_OR_EQUAL = "LESS_THAN_OR_EQUAL"
    }
    enum InteractionRuleMetricType {
        CONNECTED_DURATION = "CONNECTED_DURATION",
        HOLD_DURATION = "HOLD_DURATION",
        HOLD_COUNT = "HOLD_COUNT",
        TRANSFER_COUNT = "TRANSFER_COUNT",
        WRAP_UP_DURATION = "WRAP_UP_DURATION",
        CONSULT_DURATION = "CONSULT_DURATION",
        CONSULT_COUNT = "CONSULT_COUNT",
        AUTO_CSAT_SCORE = "AUTO_CSAT_SCORE",
        SENTIMENT_SCORE = "SENTIMENT_SCORE"
    }
}
//# sourceMappingURL=agent-performance-types.d.ts.map